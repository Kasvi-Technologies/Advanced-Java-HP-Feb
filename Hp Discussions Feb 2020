				Excercise 1 - with out Generics

1. create a Test class

2. Create a List with an implementation of ArrayList

3. add values to List with integers /strings/double ( muliple data type )

4. repeat the list and display the values



Java Generics are a language feature that allows for definition and use of generic types and methods

generics force type safety in java language

Generics add stability to your code by making more of your bugs detectable at compile time.”

https://github.com/Kasvi-Technologies/Advanced-Java-HP-Feb

		Excercise 2 - With Employee Class as generics


1. Create an Employee class with id, name and salary properties with setter and getter methods..
Note: provide default contructor and parameterized constructor
overide toString method


2. create EmployeeService class with fetchEmployees methods

	public List<Employee> fetchEmployee(){
	
		//1. create List which accepts only  Employee object
		
		2. create 3-4 Employee objects and add to List
		
		3. return the List
		
	
	}


3. Create EmployeeTest class with main method

	Fetch the Employee list and display the Employee object 

					Excercise 3 with Maps
					


							

Enums are used to create constansts and mainly used in validations like If statement/ switch statements

							Enum Excercise


1. create a Enum class called Direction

		a. define NORT, EAST, SOUTH WEST
		b. provide default values along with constructor and variable and getter methods

2. Display all Directions values in test program
	
	
							Junit


1. Write a test method to assert based on the count of employees (fetchEmployees method of EmployeeService is actual)

@BeforeClass
@AfterClass
@Before
@After
@Test
JUnitCore.runClassess

assertArrayEquals()
assertEquals()
assertTrue() + assertFalse()
assertNull() + assertNotNull()
assertSame() + assertNotSame()
	

@RunWith(Suite.class)

@Suite.SuiteClasses({ 
   MyUnitTest.class ,TestJunit.class
})


										Annotations

Annotations will specify meta data. It will not chnage your code

@Override - It will specify that method is overridden from parent class
@Deprecated -
@SupressWarnings

@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD, ElementType.FIELD, ElementType.TYPE})
@interface MyAnnotation {

	String name() default "sample";
	String value();
	int age() default 10;
	
	String[] colors();
	
}

Repeatable Annotations

@Schedule(dayOfTheWeek="Mon")
@Schedule(dayOfTheMonth="5")
Public void sendmessages(){

}




@Role(type="Administrator")
@Role(type="HR")
public void deleteEntries(){


}

						Maven
						
It will build our application automatically

Download Apache maven zip 
configure <maven-location>\bin to path environment variable
restart your IDE

from command prompt -. type mvn and enter -> it should not say that mvn command not found

						Excercises Based on Day 1

Attendence sheet - https://github.com/Kasvi-Technologies/Advanced-Java-HP-Feb

Generics- Excercise

1. Write a generic class which can accepts any type along with varibale setter and getter methods

2. Write a simple generics class example with two type parameters.

3. Let's say you have an integer array and a string array. You have to write a single method printArray 
that can print all the elements of both arrays. 

Enum - Excercise

1. create a Enum Season with WINTER, SPRING, SUMMER, FALL 

Provide default values along with constructor, variable and getter method

write a test program to print all Season's 


Annotations - Excercise

1. Create a Repeating Annotation called Role with variable value
Provide Repeating annotation only to method
Write a test program to fetch all repeating annotations using reflections
getAnnotationsByType

									Day 2 

default and static methods

1. Create a interface Vehicle 
	a. with default getCost method 

	default int getCost (){

	}
	
	b. drive method as an abstract 
	
	abstract void drive();
	

2. Create a child class called car

	a. Overide the drive method ( and cost method if you want)

3. Write a test program to create an instance of Car object and print cost and call drive emthod

	Vehicle v = new Car();
	SysOUt(c.getCost());
	v.drive();
	

Note: Uploaded the code in Github

							Functional Interfaces

//Lamda expression =  	Functional interfaces + Anonymous inner classes


Method References
	
		With Object Method
		Class Static Method
		Class COnstructor










Stream represents a sequence of objects from a source, which supports aggregate operations. 
streams are wrappers around a data source, allowing us to operate with that data source and making bulk processing convenient



										Excercise on Streams
										

1. Create a String List of around 10 values and should have some empty strings
2. Filter the Strings which is not empty and display using streams., filter and forEach. 
Hint: filter(s -> !s.isEmpty())
3. Convert the non empty strings into List
4. Display the count of empty Strings
5. Merge the non empty Strings using delimeter "," 
Hine: Collectors.joining(", ")

6. count the strings whose length is only 3
Hine: .filter(s -> s.length() == 3)

7. create an integer array and find out distinct all elements 
HInt: .distinct()

8. count of all distinct numbers in interger array

9. Square the integer elements and display the final values
Hint: .map( i -> i*i)

10. create an integer array which contains values from 1 to 100. 
	a. create a stream and filter out more than 90 and display the values
	b. create a parallelStream() and filter out more than 90 and display the values. 
	
	Note: Observe the result for both display. parallelStream() performs the business logic parallelly





stream() − Returns a sequential stream considering collection as its source.
parallelStream() − Returns a parallel Stream considering collection as its source.


List<String> filtered = strings.stream().filter(string -> !string.isEmpty()).collect(Collectors.toList());

forEach
map
colect

filter
findFirst

toArray
Employee[] employees = empList.stream().toArray(Employee[]::new);


The ‘map’ method is used to map each element to its corresponding result. 
map() produces a new stream after applying a function to each element of the original stream. 

Integer[] empIds = { 1, 2, 3 };
    
    List<Employee> employees = Stream.of(empIds)
      .map(employeeRepository::findById)
      .collect(Collectors.toList());
	  
	  
	  List<Employee> employees = Stream.of(empIds)
      .map(employeeRepository::findById)
      .filter(e -> e != null)
      .filter(e -> e.getSalary() > 200000)
      .collect(Collectors.toList());
	  
	  
List<Integer> squaresList = numbers.stream().map( i -> i*i).distinct().collect(Collectors.toList())

int count = strings.stream().filter(string -> string.isEmpty()).count();

.limit(10).forEach(System.out::println);
Collectors
Collectors are used to combine the result of processing on the elements of a stream. Collectors can be used to return a list or a string.

String mergedString = strings.stream().filter(string -> !string.isEmpty()).collect(Collectors.joining(", "));


Statistics
With Java 8, statistics collectors are introduced to calculate all statistics when stream processing is being done.
List numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);

IntSummaryStatistics stats = numbers.stream().mapToInt((x) -> x).summaryStatistics();

System.out.println("Highest number in List : " + stats.getMax());
System.out.println("Lowest number in List : " + stats.getMin());
System.out.println("Sum of all numbers : " + stats.getSum());
System.out.println("Average of all numbers : " + stats.getAverage());

 count = strings.stream().filter(string->string.isEmpty()).count();
 count = strings.stream().filter(string -> string.length() == 3).count();
 filtered = strings.stream().filter(string ->!string.isEmpty()).collect(Collectors.toList());
 mergedString = strings.stream().filter(string ->!string.isEmpty()).collect(Collectors.joining(", "));
 squaresList = numbers.stream().map( i ->i*i).distinct().collect(Collectors.toList());
  IntSummaryStatistics stats = integers.stream().mapToInt((x) ->x).summaryStatistics();
  
  count = strings.parallelStream().filter(string -> string.isEmpty()).count();



forEach() earlier in this section, which is a terminal operation. However, 
sometimes we need to perform multiple operations on each element of the stream before any terminal operation is applied.

peek() is an intermediate operation

List<Employee> empList = Arrays.asList(arrayOfEmps);
    
    empList.stream()
      .peek(e -> e.salaryIncrement(10.0))
      .peek(System.out::println)
      .collect(Collectors.toList());



Infinite Loop

Stream<Integer> infiniteStream = Stream.iterate(2, i -> i * 2);

    List<Integer> collect = infiniteStream
      .skip(3)
      .limit(5)
      .collect(Collectors.toList());












































































									




 Result result = JUnitCore.runClasses(TestJunit.class);

 
 
 @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.METHOD})
 
 
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	